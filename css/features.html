<h1>Features</h1>
<h2>Graphs</h2>
<p>
    A graph consists of a set of vertices and edges, where each individual node and edge possesses a map of properties. A vertex is the basic object of a graph, that can exist independently of everything else in the graph. An edge creates a
    directed connection between two vertices.
</p>
<h3>Create a Graph</h3>
<p>To create a graph, use the create_graph function, located in the ag_catalog namespace.</p>
<p>create_graph()</p>
<p>Syntax: create_graph(graph_name);</p>
<p>Returns:</p>
<table>
    <tbody>
        <tr>
            <td width="624">
                <p>void</p>
            </td>
        </tr>
    </tbody>
</table>
<p>Arguments:</p>
<table>
    <tbody>
        <tr>
            <td width="312">
                <p>Name</p>
            </td>
            <td width="312">
                <p>Description</p>
            </td>
        </tr>
        <tr>
            <td width="312">
                <p>graph_name</p>
            </td>
            <td width="312">
                <p>Name of the graph to be created</p>
            </td>
        </tr>
    </tbody>
</table>
<p>Considerations</p>
<ul>
    <li>This function will not return any results. However if there is not an error message the graph will be created.</li>
    <li>Tables needed to set up the graph are automatically created.</li>
</ul>
<p>Example:</p>
<table>
    <tbody>
        <tr>
            <td width="624">
                <p>SELECT&nbsp;* FROM&nbsp;ag_catalog.create_graph('graph_name');</p>
            </td>
        </tr>
    </tbody>
</table>
<h3>Delete a Graph</h3>
<p>To delete a graph, use the drop_graph function, located in the ag_catalog namespace.</p>
<p>drop_graph()</p>
<p>Syntax: drop_graph(graph_name, cascade);</p>
<p>Returns:</p>
<table>
    <tbody>
        <tr>
            <td width="624">
                <p>void</p>
            </td>
        </tr>
    </tbody>
</table>
<p>Arguments:</p>
<table>
    <tbody>
        <tr>
            <td width="312">
                <p>Name</p>
            </td>
            <td width="312">
                <p>Description</p>
            </td>
        </tr>
        <tr>
            <td width="312">
                <p>graph_name</p>
            </td>
            <td width="312">
                <p>Name of the graph to be created</p>
            </td>
        </tr>
        <tr>
            <td width="312">
                <p>cascade</p>
            </td>
            <td width="312">
                <p>A boolean that will not drop the graph if any data remains in the graph.</p>
            </td>
        </tr>
    </tbody>
</table>
<p>Considerations:</p>
<ul>
    <li>This function will not return any results. However if there is not an error message the graph will be created.</li>
    <li>It is recommended to set the cascade option to true, otherwise everything in the graph must be manually dropped with SQL DDL commands.</li>
</ul>
<p>Example:</p>
<table>
    <tbody>
        <tr>
            <td width="624">
                <p>SELECT&nbsp;* FROM&nbsp;ag_catalog.drop_graph('graph_name', true);</p>
            </td>
        </tr>
    </tbody>
</table>
<h3>A Cypher Graph vs A Postgres Namespace</h3>
<p>Cypher uses a Postgres namespace for every individual graph. It is recommended that no DML or DDL commands are executed in the namespace that is reserved for the graph.</p>
<h2>Data Types - An Introduction to agtype</h2>
<p>AGE uses a custom data type called agtype, which is the only data type returned by AGE. Agtype is a superset of Json and a custom implementation of JsonB.</p>
<h3>Simple Data Types</h3>
<h4>Null</h4>
<p>
    In Cypher, null&nbsp;is used to represent missing or undefined values. Conceptually, null&nbsp;means 'a missing unknown value' and it is treated somewhat differently from other values. For example getting a property from a vertex that
    does not have said property produces null. Most expressions that take null&nbsp;as input will produce null. This includes boolean expressions that are used as predicates in the WHERE&nbsp;clause. In this case, anything that is not
    true&nbsp;is interpreted as being false.&nbsp;null&nbsp;is not equal to null. Not knowing two values does not imply that they are the same value. So the expression null&nbsp;= null&nbsp;yields null&nbsp;and not true.
</p>
<p>Input/Output Format</p>
<p>Query</p>
<table>
    <tbody>
        <tr>
            <td width="624">
                <p>
                    SELECT&nbsp;*<br />
                    FROM&nbsp;cypher('graph_name', $$<br />
                    RETURN&nbsp;NULL<br />
                    $$) AS&nbsp;(null_result agtype);
                </p>
            </td>
        </tr>
    </tbody>
</table>
<p>A null will appear as an empty space.</p>
<p>Result:</p>
<table>
    <tbody>
        <tr>
            <td width="624">
                <p>null_result</p>
            </td>
        </tr>
        <tr></tr>
        <tr>
            <td width="624">
                <p>(1 row)</p>
            </td>
        </tr>
    </tbody>
</table>
<p>Agtype NULL vs Postgres NULL</p>
<h4>Integer</h4>
<p>
    The integer type stores whole numbers, i.e. numbers without fractional components. Integer data type is a 64-bit field that stores values between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807. Attempts to store values outside
    of the allowed range will result in an error.
</p>
<p>
    The type integer is the common choice, as it offers the best balance between range, storage size, and performance. The smallint type is generally only used if disk space is at a premium. The bigint type is designed to be used when the
    range of the integer type is insufficient.
</p>
<p>Input/Output Format</p>
<p>Query</p>
<table>
    <tbody>
        <tr>
            <td width="624">
                <p>
                    SELECT&nbsp;*<br />
                    FROM&nbsp;cypher('graph_name', $$<br />
                    RETURN&nbsp;1<br />
                    $$) AS&nbsp;(int_result agtype);
                </p>
            </td>
        </tr>
    </tbody>
</table>
<p>Result:</p>
<table>
    <tbody>
        <tr>
            <td width="624">
                <p>int_result</p>
            </td>
        </tr>
        <tr>
            <td width="624">
                <p>1</p>
            </td>
        </tr>
        <tr>
            <td width="624">
                <p>(1 row)</p>
            </td>
        </tr>
    </tbody>
</table>
<h4>Float</h4>
<p>The data type float is an inexact, variable-precision numeric type, conforming to the IEEE-754 Standard.</p>
<p>
    Inexact means that some values cannot be converted exactly to the internal format and are stored as approximations, so that storing and retrieving a value might show slight discrepancies. Managing these errors and how they propagate
    through calculations is the subject of an entire branch of mathematics and computer science and will not be discussed here, except for the following points:
</p>
<ul>
    <li>If you require exact storage and calculations (such as for monetary amounts), use the numeric type instead.</li>
    <li>If you want to do complicated calculations with these types for anything important, especially if you rely on certain behavior in boundary cases (infinity, underflow), you should evaluate the implementation carefully.</li>
    <li>Comparing two floating-point values for equality might not always work as expected.</li>
</ul>
<p>
    Values that are too large or too small will cause an error. Rounding might take place if the precision of an input number is too high. Numbers too close to zero that are not representable as distinct from zero will cause an underflow
    error.
</p>
<p>In addition to ordinary numeric values, the floating-point types have several special values:</p>
<ul>
    <li>Infinity</li>
    <li>-Infinity</li>
    <li>NaN</li>
</ul>
<p>
    These represent the IEEE 754 special values &ldquo;infinity&rdquo;, &ldquo;negative infinity&rdquo;, and &ldquo;not-a-number&rdquo;, respectively. When writing these values as constants in a Cypher command, you must put quotes around
    them and typecast them, for example SET x.float_value = '-Infinity'::float. On input, these strings are recognized in a case-insensitive manner.
</p>
<table>
    <tbody>
        <tr>
            <td width="624">
                <p>
                    Note<br />
                    IEEE754 specifies that NaN should not compare equal to any other floating-point value (including NaN). However, in order to allow floats to be sorted correctly, AGE evaluates &lsquo;NaN&rsquo;::float =
                    &lsquo;NaN&rsquo;:float to true. See the section <a href="#h.3dsme7gtj4ch">Comparability and Equality</a>&nbsp;for more details.
                </p>
            </td>
        </tr>
    </tbody>
</table>
<p>Input/Output Format:</p>
<p>To use a float, denote a decimal value.</p>
<p>Query</p>
<table>
    <tbody>
        <tr>
            <td width="624">
                <p>
                    SELECT&nbsp;*<br />
                    FROM&nbsp;cypher('graph_name', $$<br />
                    RETURN&nbsp;1.0<br />
                    $$) AS&nbsp;(float_result agtype);
                </p>
            </td>
        </tr>
    </tbody>
</table>
<p>Result:</p>
<table>
    <tbody>
        <tr>
            <td width="624">
                <p>float_result</p>
            </td>
        </tr>
        <tr>
            <td width="624">
                <p>1.0</p>
            </td>
        </tr>
        <tr>
            <td width="624">
                <p>(1 row)</p>
            </td>
        </tr>
    </tbody>
</table>
<h4>Numeric</h4>
<p>
    The type numeric can store numbers with a very large number of digits. It is especially recommended for storing monetary amounts and other quantities where exactness is required. Calculations with numeric values yield exact results
    where possible, e.g., addition, subtraction, multiplication. However, calculations on numeric values are very slow compared to the integer types, or to the floating-point type.
</p>
<p>
    We use the following terms below: The precision&nbsp;of a numeric is the total count of significant digits in the whole number, that is, the number of digits to both sides of the decimal point. The scale&nbsp;of a numeric is the count
    of decimal digits in the fractional part, to the right of the decimal point. So the number 23.5141 has a precision of 6 and a scale of 4. Integers can be considered to have a scale of zero.
</p>
<p>
    Without any precision or scale creates a column in which numeric values of any precision and scale can be stored, up to the implementation limit on precision. A column of this kind will not coerce input values to any particular scale,
    whereas numeric columns with a declared scale will coerce input values to that scale. (The SQL standard requires a default scale of 0, i.e., coercion to integer precision. We find this a bit useless. If you're concerned about
    portability, always specify the precision and scale explicitly.)
</p>
<table>
    <tbody>
        <tr>
            <td width="624">
                <p>
                    Note<br />
                    The maximum allowed precision when explicitly specified in the type declaration is 1000; NUMERIC without a specified precision is subject to the limits described in Table 8.2.
                </p>
            </td>
        </tr>
    </tbody>
</table>
<p>
    If the scale of a value to be stored is greater than the declared scale of the column, the system will round the value to the specified number of fractional digits. Then, if the number of digits to the left of the decimal point exceeds
    the declared precision minus the declared scale, an error is raised.
</p>
<p>
    Numeric values are physically stored without any extra leading or trailing zeroes. Thus, the declared precision and scale of a column are maximums, not fixed allocations. (In this sense the numeric type is more akin to varchar(n) than
    to char(n).) The actual storage requirement is two bytes for each group of four decimal digits, plus three to eight bytes overhead.
</p>
<p>
    In addition to ordinary numeric values, the numeric type allows the special value NaN, meaning &ldquo;not-a-number&rdquo;. Any operation on NaN yields another NaN. When writing this value as a constant in an SQL command, you must put
    quotes around it, for example UPDATE table SET x = 'NaN'. On input, the string NaN is recognized in a case-insensitive manner.
</p>
<table>
    <tbody>
        <tr>
            <td width="624">
                <p>
                    Note<br />
                    In most implementations of the "not-a-number" concept, NaN is not considered equal to any other numeric value (including NaN). However, in order to allow floats to be sorted correctly, AGE evaluates
                    &lsquo;NaN&rsquo;::numeric = &lsquo;NaN&rsquo;:numeric to true. See the section <a href="#h.3dsme7gtj4ch">Comparability and Equality</a>&nbsp;for more details.
                </p>
            </td>
        </tr>
    </tbody>
</table>
<p>When rounding values, the numeric type rounds ties away from zero, while (on most machines) the real and double precision types round ties to the nearest even number. For example:</p>
<p>Input/Output Format:</p>
<p>When creating a numeric data type, the &lsquo;::numeric&rsquo; data annotation is required.</p>
<p>Query</p>
<table>
    <tbody>
        <tr>
            <td width="624">
                <p>
                    SELECT&nbsp;*<br />
                    FROM&nbsp;cypher('graph_name', $$<br />
                    RETURN&nbsp;1.0::numeric<br />
                    $$) AS&nbsp;(numeric_result agtype);
                </p>
            </td>
        </tr>
    </tbody>
</table>
<p>Result:</p>
<table>
    <tbody>
        <tr>
            <td width="624">
                <p>numeric_result</p>
            </td>
        </tr>
        <tr>
            <td width="624">
                <p>1.0::numeric</p>
            </td>
        </tr>
        <tr>
            <td width="624">
                <p>(1 row)</p>
            </td>
        </tr>
    </tbody>
</table>
<h4>Bool</h4>
<p>AGE provides the standard Cypher type boolean. The boolean type can have several states: &ldquo;true&rdquo;, &ldquo;false&rdquo;, and a third state, &ldquo;unknown&rdquo;, which is represented by the Agtype null value.</p>
<p>Boolean constants can be represented in Cypher queries by the keywords TRUE, FALSE, and NULL.</p>
<p>
    Note that the parser automatically understands that TRUE and FALSE are of type boolean, but this is not so for NULL because that can have any type. So in some contexts you might have to cast NULL to boolean explicitly, for example
    NULL::boolean. Conversely, the cast can be omitted from a string-literal Boolean value in contexts where the parser can deduce that the literal must be of type boolean.
</p>
<p>Input/Output Format</p>
<p>Query</p>
<table>
    <tbody>
        <tr>
            <td width="624">
                <p>
                    SELECT&nbsp;*<br />
                    FROM&nbsp;cypher('graph_name', $$<br />
                    RETURN&nbsp;TRUE<br />
                    $$) AS&nbsp;(boolean_result agtype);
                </p>
            </td>
        </tr>
    </tbody>
</table>
<p>Unlike Postgres, AGE&rsquo;s boolean outputs as the full word, ie. true and false as opposed to t and f.</p>
<p>Result:</p>
<table>
    <tbody>
        <tr>
            <td width="624">
                <p>boolean_result</p>
            </td>
        </tr>
        <tr>
            <td width="624">
                <p>true</p>
            </td>
        </tr>
        <tr>
            <td width="624">
                <p>(1 row)</p>
            </td>
        </tr>
    </tbody>
</table>
<h4>String</h4>
<p>Agtype strings String literals can contain the following escape sequences:</p>
<table>
    <tbody>
        <tr>
            <td width="312">
                <p>Escape Sequence</p>
            </td>
            <td width="312">
                <p>Character</p>
            </td>
        </tr>
        <tr>
            <td width="312">
                <p>\t</p>
            </td>
            <td width="312">
                <p>Tab</p>
            </td>
        </tr>
        <tr>
            <td width="312">
                <p>\b</p>
            </td>
            <td width="312">
                <p>Backspace</p>
            </td>
        </tr>
        <tr>
            <td width="312">
                <p>\n</p>
            </td>
            <td width="312">
                <p>Newline</p>
            </td>
        </tr>
        <tr>
            <td width="312">
                <p>\r</p>
            </td>
            <td width="312">
                <p>Carriage Return</p>
            </td>
        </tr>
        <tr>
            <td width="312">
                <p>\f</p>
            </td>
            <td width="312">
                <p>Form Feed</p>
            </td>
        </tr>
        <tr>
            <td width="312">
                <p>\&rsquo;</p>
            </td>
            <td width="312">
                <p>Single Quote</p>
            </td>
        </tr>
        <tr>
            <td width="312">
                <p>\&rdquo;</p>
            </td>
            <td width="312">
                <p>Double Quote</p>
            </td>
        </tr>
        <tr>
            <td width="312">
                <p>\\</p>
            </td>
            <td width="312">
                <p>Backslash</p>
            </td>
        </tr>
        <tr>
            <td width="312">
                <p>\uXXXX</p>
            </td>
            <td width="312">
                <p>Unicode UTF-16 code point (4 hex digits must follow the \u)</p>
            </td>
        </tr>
    </tbody>
</table>
<p>Input/Output Format</p>
<p>Use single (&lsquo;) quotes to identify a string. The output will use double (&ldquo;) quotes.</p>
<p>Query</p>
<table>
    <tbody>
        <tr>
            <td width="624">
                <p>
                    SELECT&nbsp;*<br />
                    FROM&nbsp;cypher('graph_name', $$<br />
                    RETURN &lsquo;This is a string&rsquo;<br />
                    $$) AS&nbsp;(string_result agtype);
                </p>
            </td>
        </tr>
    </tbody>
</table>
<p>Result:</p>
<table>
    <tbody>
        <tr>
            <td width="624">
                <p>string_result</p>
            </td>
        </tr>
        <tr>
            <td width="624">
                <p>&ldquo;This is a string&rdquo;</p>
            </td>
        </tr>
        <tr>
            <td width="624">
                <p>(1 row)</p>
            </td>
        </tr>
    </tbody>
</table>
<h3>Composite Data Types</h3>
